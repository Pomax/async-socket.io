import oe from"http";import se from"https";import{WebSocket as he,WebSocketServer as re}from"ws";import{WebSocket as ie}from"ws";var P="server",$="client",W="webclient",b="browser";var k=class{constructor(t,e){this.originName=t,this.message=e}},u=!1;function ce(){let o=Date.now().toString(16),t=(1e6*Math.random()|0).toString(16);return`${o}-${t}`}var H=":response",j=o=>`${o}${H}`,I=Symbol("origin"),D=Symbol("proxy"),v=Symbol("receiver"),B=Symbol("remote"),N=Symbol("handlers"),L=class o extends ie{[I]=void 0;[D]=void 0;[v]="";[B]="";[N]={};constructor(){throw new Error("Cannot create UpgradedSocket instances. Use UpgradedSocket.upgrade(name, origin, socket) instead.")}static upgrade(t,e,n,s){if(t instanceof o)return t;Object.setPrototypeOf(t,o.prototype),t[I]=e,t[v]=n,t[B]=s,t[N]={};let r=t.router.bind(t);return t.on?t.on("message",r):t.onmessage=r,t}get upgraded(){return this.__upgraded||(this.__upgraded={on:(...t)=>this.__on(...t),off:(...t)=>this.__off(...t),send:(...t)=>this.__send(...t)}),this.__upgraded}async router(t){let{[I]:e,[v]:n,[B]:s}=this;if(s===b)return;t.srcElement&&(t=t.data);let r;try{r=JSON.parse(t)}catch{return console.error(`Could not parse websocket data: ${t}`)}let{name:i,payload:l,error:c,diff:a,seq_num:h}=r,{state:f}=r,p=c?new k(n,c):void 0;if(u&&console.log(`[${n}]/[${s}] router running given:`,{eventName:i,payload:l,errorMsg:c,state:f,diff:a,seq_num:h}),f&&n===b){u&&console.log("handling state update in the browser",f),u&&console.log("origin object:",{origin:e});let d=JSON.parse(JSON.stringify(e.state));if(a){u&&console.log("received diff",f);let y=f,E;if(h===e.__seq_num+1)e.__seq_num=h,E=JSON.parse(JSON.stringify(d)),u&&console.log("applying patch to",E),rfc6902.applyPatch(E,y);else{u&&console.log("seq_num mismatch, syncing state");let J=await this.__send("syncState");e.__seq_num=0,E=J}f=E}return e.state=f,e.update(d)}if(i.endsWith(H)){let{[N]:d}=this;if(u&&console.log(`[${n}] response message received`),!d[i])throw new Error(`no handlers for ${i}`);d[i].forEach(y=>{y(p||l)});return}if(l&&!Array.isArray(l))throw new Error(`[${n}] received payload for ${i} from [${s}] but it was not an array? ${JSON.stringify(l,null,2)}`);let g=i.split(":");u&&console.log(`[${n}] router: stages:`,g);let m=e,C=e.__proto__?.constructor.disallowedCalls??[],w,_;try{let[d]=g;if(g.length===1&&C.includes(d))throw new Error(`Illegal call: ${d} is a protected method`);for(;g.length;){let y=g.shift();u&&console.log(`checking ${y}`),m=m[y]}n==="server"&&l.unshift(this[D])}catch(d){u&&console.error(`cannot resolve ${i} on ${n}`,d),w=d.message}if(!w)try{_=await m.bind(e)(...l)??!0,n===$&&e.browser&&e.setState(e.state)}catch(d){u&&console.error(`function invocation for ${i} failed on ${n}, payload:`,l),u&&console.error(d),w=d.message}let x=j(i);u&&console.log(`[${n}] sending ${x}`,{payload:_,error:w}),super.send(JSON.stringify({name:x,payload:_,error:w}))}__on(t,e){let{[N]:n}=this;return n[t]||(n[t]=[]),n[t].push(e),()=>this.__off(t,e)}__off(t,e){let{[N]:n}=this;if(!n[t])return;let s=n[t].indexOf(e);n[t].splice(s,1)}async __send(t,e={},n=1e3){let{[v]:s,[B]:r}=this;return u&&console.log(`[${s}] sending [${t}] to [${r}]:`,e),await new Promise((i,l)=>{let c=j(t),a=(p=void 0)=>{u&&console.log(`[${s}] cleanup`),this.__off(c,h),a=()=>{},i(p)},h=p=>a(p);this.__on(c,p=>{u&&console.log(`[${s}] handling response for ${t} from [${r}]:`),h(p)});let f=()=>{u&&console.log(`(raw) sending ${t} from ${s} to ${r}`),super.send(JSON.stringify({name:t,payload:e}))};super.readyState===1?f():super.onopen=f,setTimeout(()=>a(),n)})}},U=class o extends Function{constructor(t,e,n,s=""){return super(),this[v]=e,this[B]=n,this.id=ce(),this.path=s,this.socket=t,new Proxy(this,{get:(r,i)=>i==="id"?this.id:i==="socket"?this.socket:new o(t,e,n,`${s}:${i}`),apply:async(r,i,l)=>{u&&console.log(`[SPapply] sending ${this.path.substring(1)} receiver ${this[v]} to ${this[B]}`);let c=await this.socket.upgraded.send(this.path.substring(1),l);if(c instanceof k){let a=[...new Array(l.length)].map((h,f)=>String.fromCharCode(97+f)).join(",");throw u&&console.error(`ERROR calling [[${c.originName}]].${this.path.substring(1).replaceAll(":",".")}(${a}): ${c.message}`),new Error(c.message)}return c}})}};function R(o,t,e,n){return n=L.upgrade(n,e,o,t),n[D]=new U(n,o,t)}var S=!1,q=Symbol();function F(o){return class A extends o{static get disallowedCalls(){let e=Object.getOwnPropertyNames(A.prototype);return["constructor","disconnect"].forEach(n=>e.splice(e.indexOf(n),1)),e}constructor(){super();let e=this[q]={},n=new Proxy(e,{get:(s,r)=>e[r],set:()=>{throw new Error("cannot directly assign to state, use setState(update)")}});Object.defineProperty(this,"state",{value:n,writable:!1,configurable:!1}),this.onConnect||(this.onConnect=async()=>{S&&console.log(`[ClientBase] client ${this.state.id} connected.`)}),this.onDisconnect||(this.onDisconnect=async()=>{S&&console.log(`[ClientBase] client ${this.state.id} disconnected.`)}),this.onQuit||(this.onQuit=async()=>{S&&console.log(`[ClientBase] client ${this.state.id} quitting.`)})}setState(e){S&&console.log("[ClientBase] updating state");let n=this[q];Object.entries(e).forEach(([s,r])=>n[s]=r)}connectServerSocket(e){S&&console.log("[ClientBase]  connected to server"),this.server=R($,P,this,e),this.onConnect()}disconnect(){this.server.socket.close()}}}function G(o){return class Q extends o{clients=[];ws=void 0;webserver=void 0;static get disallowedCalls(){let e=Object.getOwnPropertyNames(Q.prototype);return e.splice(e.indexOf("constructor"),1),e}constructor(e,n){super(),this.ws=e,this.webserver=n}async connectClientSocket(e){S&&console.log("[ServerBase] client connecting to server...");let n=R(P,$,this,e);S&&console.log("[ServerBase] sending connection id"),n.socket.send(JSON.stringify({name:"handshake:setid",payload:{id:n.id}})),S&&console.log("[ServerBase] adding client to list of known clients"),this.clients.push(n),this.addDisconnectHandling(n,e),this.onConnect(n)}async addDisconnectHandling(e,n){let{clients:s}=this;n.on("close",()=>{let r=s.findIndex(i=>i===e);if(r!==-1){let i=s.splice(r,1)[0];this.onDisconnect(e)}})}async onDisconnect(e){if(super.onDisconnect)return super.onDisconnect(e);S&&console.log(`[ServerBase] client ${e.id} disconnected.`)}async onConnect(e){if(super.onConnect)return super.onConnect(e);S&&console.log(`[ServerBase] client ${e.id} connected.`)}async quit(){await this.onQuit(),this.clients.forEach(e=>e.disconnect()),this.webserver.close(),this.ws.close(),this.teardown()}async onQuit(){if(super.onQuit)return super.onQuit();S&&console.log("[ServerBase] told to quit.")}async teardown(){if(super.teardown)return super.teardown();S&&console.log("[ServerBase] post-quit teardown.")}}}import{createPatch as ae}from"rfc6902";var O=!1;function Y(o){return class M extends o{browser=void 0;static get disallowedCalls(){let e=Object.getOwnPropertyNames(M.prototype).concat(o.disallowedCalls);return["constructor","quit","syncState"].forEach(n=>e.splice(e.indexOf(n),1)),e}connectBrowserSocket(e){this.browser||(this.browser=R(W,b,this,e),this.browser.socket.__seq_num=0,this.setState(this.state))}disconnectBrowserSocket(){this.browser=void 0}setState(e){if(O&&console.log("[WebClientBase] setState"),super.setState(e),O&&console.log("[WebClientBase] client has browser?",!!this.browser),this.browser){O&&console.log("[WebClientBase] creating diff as part of setState");let n=ae(this.__oldState??{},this.state);if(n.length>0){let s={state:n,seq_num:++this.browser.socket.__seq_num,diff:!0};O&&console.log("[WebClientBase] sending diff as part of setState:",s),this.browser.socket.send(JSON.stringify(s))}else O&&console.log("no difference, skipping state sync.")}this.__oldState=JSON.parse(JSON.stringify(this.state))}syncState(){if(this.browser){O&&console.log("[WebClientBase] running syncState (will respond with full state)");let e=JSON.parse(JSON.stringify(this.state));return this.browser.socket.__seq_num=0,O&&console.log("[WebClientBase] responding with full state:",e),e}throw new Error("[WebClientBase] Cannot sync state: no browser attached to client.")}quit(){this.browser&&(this.browser.socket.close(),this.disconnectBrowserSocket()),this.disconnect(),this.onQuit()}}}var T=class{constructor(t){this.client=t,this.routes={}}addRouteHandler(t,e){this.routes[t]=e}handle(t,e,n){let s=this.routes[t];return s?(s(this.client,e,n),!0):!1}};import fe from"fs";import{join as Z}from"path";import V from"fs";import z from"path";import le from"url";var X=le.fileURLToPath(new URL(".",import.meta.url));function K(){let o=V.readFileSync(z.join(X,"../upgraded-socket.js")).toString("utf-8").replace('import { WebSocket } from "ws";',"").replace('import { CLIENT, BROWSER } from "./sources.js";',`const BROWSER = "${b}";
const CLIENT = "${$}";`).replaceAll("export function","function"),t=`
    export function createWebClient(WebClientClass) {
      const socket = new WebSocket(window.location.toString().replace("http", "ws"));
      const browserClient = new WebClientClass();
      Object.defineProperty(browserClient, "socket", {
        value: socket,
        writable: false,
        configurable: false,
        enumerable: false
      });
      Object.defineProperty(browserClient, "server", {
        value: proxySocket("${b}", "${W}", browserClient, socket),
        writable: false,
        configurable: false,
        enumerable: false
      });
      Object.defineProperty(browserClient, "quit", {
        value: () => browserClient.server.disconnect()
      });
      browserClient.state = {};
      browserClient.init();
      return browserClient;
    };
  `,e=V.readFileSync(z.join(X,"../../node_modules/rfc6902/dist/rfc6902.min.js")).toString("utf-8");return[o,t,e].join(`
`)}var ee={".html":"text/html",".css":"text/css",".js":"application/javascript",".jpg":"image/jpeg",".png":"image/png"},de="text/plain";function te(o){let t=Object.keys(ee).find(n=>o.slice(-n.length)===n);return ee[t]||de}function ue(o,t){return o==="/"?Z(t,"index.html"):(o=o.substring(1),o=o.replace(/\.\./g,"").replace(/\/\//g,"/"),o=Z(t,o),o)}function pe(o,t){console.error(`Can't serve ${o}, so it probably doesn't exist`),t.writeHead(404,{"Content-Type":"text/html"}),t.end("<doctype html><html><body>resource not found</html>")}function ne(o,t){let e=K();return(n,s)=>{if(n.url.includes("?")){let[l,c]=n.url.split(/\\?\?/);n.url=l,n.params=new URLSearchParams(c)}let r=n.url;if(r==="/favicon.ico")return s.writeHead(200,{"Content-Type":"text/plain"}),s.end("","utf-8");if(r==="/socketless.js")return s.writeHead(200,{"Content-Type":te(".js")}),s.end(e,"utf-8");if(!t.handle(r,n,s)){var i=ue(n.url,o);fe.readFile(i,(l,c)=>{if(l)return pe(i,s);s.writeHead(200,{"Content-Type":te(i)}),s.end(c,"utf-8")})}}}function Fe(o,t){o=F(o),t=G(t);let e=Y(o),n={createServer:function(r){let i,l;r?.constructor===Object?l=r:i=r;let c=i;c||(c=l?se.createServer(l):oe.createServer());let a=new re({noServer:!0});c.on("upgrade",(f,p,g)=>{a.handleUpgrade(f,p,g,m=>{a.emit("connection",m,f)})});let h=new t(a,c);return a.on("connection",function(f){h.connectClientSocket(f)}),c},createClient:function(r,i,l=o){r=r.replace("http","ws");let c=new he(r,{rejectUnauthorized:!i}),a=new l;c.on("close",(...f)=>a.onDisconnect(...f));function h(f){try{let{name:p,payload:g}=JSON.parse(f);p==="handshake:setid"&&(c.off("message",h),a.setState(g),a.connectServerSocket(c))}catch{}}return c.on("message",h),a},createWebClient:function(r,i,l,c){let a=n.createClient(r,c,e),h=new T(a),f=ne(i,h),p=l?se.createServer(l,f):oe.createServer(f),g=new re({noServer:!0});return p.on("upgrade",(m,C,w)=>{g.handleUpgrade(m,C,w,_=>{g.emit("connection",_,m)})}),a.ws=g,a.webserver=p,g.on("connection",m=>{a.connectBrowserSocket(m),m.on("message",async C=>{C=C.toString();let{name:w,payload:_}=JSON.parse(C),x=j(w);if(w==="syncState"){let J=await a.syncState();return m.send(JSON.stringify({name:x,payload:J}))}if(w==="disconnect")return a.disconnect();let d=a.server,y=w.split(":");for(;y.length;)d=d[y.shift()];let E=await d(..._);m.send(JSON.stringify({name:x,payload:E}))}),m.on("close",()=>{a.disconnectBrowserSocket()})}),p.addRoute=h.addRouteHandler.bind(h),p}};return n}export{Fe as generateClientServer};
