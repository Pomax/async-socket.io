import gg from"http";import Ig from"https";import{WebSocket as Zg,WebSocketServer as Cg}from"ws";import{WebSocket as lg}from"ws";var v="server",p="client",U="webclient",S="browser";var R=class{constructor(I,g){this.originName=I,this.message=g}},d=!1;function cg(){let l=Date.now().toString(16),I=(1e6*Math.random()|0).toString(16);return`${l}-${I}`}var x=":response",H=l=>`${l}${x}`,F=Symbol("origin"),f=Symbol("proxy"),y=Symbol("receiver"),r=Symbol("remote"),K=Symbol("handlers"),k=class l extends lg{[F]=void 0;[f]=void 0;[y]="";[r]="";[K]={};constructor(){throw new Error("Cannot create UpgradedSocket instances. Use UpgradedSocket.upgrade(name, origin, socket) instead.")}static upgrade(I,g,C,c){if(I instanceof l)return I;Object.setPrototypeOf(I,l.prototype),I[F]=g,I[y]=C,I[r]=c,I[K]={};let o=I.router.bind(I);return I.on?I.on("message",o):I.onmessage=o,I}get upgraded(){return this.__upgraded||(this.__upgraded={on:(...I)=>this.__on(...I),off:(...I)=>this.__off(...I),send:(...I)=>this.__send(...I)}),this.__upgraded}async router(I){let{[F]:g,[y]:C,[r]:c}=this;if(c===S)return;I.srcElement&&(I=I.data);let o;try{o=JSON.parse(I)}catch{return console.error(`Could not parse websocket data: ${I}`)}let{name:t,payload:e,error:i,diff:n,seq_num:b}=o,{state:Z}=o,G=i?new R(C,i):void 0;if(d&&console.log(`[${C}]/[${c}] router running given:`,{eventName:t,payload:e,errorMsg:i,state:Z,diff:n,seq_num:b}),Z&&C===S){d&&console.log("handling state update in the browser",Z),d&&console.log("origin object:",{origin:g});let s=JSON.parse(JSON.stringify(g.state));if(n){d&&console.log("received diff",Z);let B=Z,u;if(b===g.__seq_num+1)g.__seq_num=b,u=JSON.parse(JSON.stringify(s)),d&&console.log("applying patch to",u),rfc6902.applyPatch(u,B);else{d&&console.log("seq_num mismatch, syncing state");let w=await this.__send("syncState");g.__seq_num=0,u=w}Z=u}return g.state=Z,g.update(s)}if(t.endsWith(x)){let{[K]:s}=this;if(d&&console.log(`[${C}] response message received`),!s[t])throw new Error(`no handlers for ${t}`);s[t].forEach(B=>{B(G||e)});return}if(e&&!Array.isArray(e))throw new Error(`[${C}] received payload for ${t} from [${c}] but it was not an array? ${JSON.stringify(e,null,2)}`);let A=t.split(":");d&&console.log(`[${C}] router: stages:`,A);let m=g,Y=g.__proto__?.constructor.disallowedCalls??[],a,W;try{let[s]=A;if(A.length===1&&Y.includes(s))throw new Error(`Illegal call: ${s} is a protected method`);for(;A.length;){let B=A.shift();d&&console.log(`checking ${B}`),m=m[B]}C==="server"&&e.unshift(this[f])}catch(s){d&&console.error(`cannot resolve ${t} on ${C}`,s),a=s.message}if(!a)try{W=await m.bind(g)(...e)??!0,C===p&&g.browser&&g.setState(g.state)}catch(s){d&&console.error(`function invocation for ${t} failed on ${C}, payload:`,e),d&&console.error(s),a=s.message}let X=H(t);d&&console.log(`[${C}] sending ${X}`,{payload:W,error:a}),super.send(JSON.stringify({name:X,payload:W,error:a}))}__on(I,g){let{[K]:C}=this;return C[I]||(C[I]=[]),C[I].push(g),()=>this.__off(I,g)}__off(I,g){let{[K]:C}=this;if(!C[I])return;let c=C[I].indexOf(g);C[I].splice(c,1)}async __send(I,g={},C=1e3){let{[y]:c,[r]:o}=this;return d&&console.log(`[${c}] sending [${I}] to [${o}]:`,g),await new Promise((t,e)=>{let i=H(I),n=(G=void 0)=>{d&&console.log(`[${c}] cleanup`),this.__off(i,b),n=()=>{},t(G)},b=G=>n(G);this.__on(i,G=>{d&&console.log(`[${c}] handling response for ${I} from [${o}]:`),b(G)});let Z=()=>{d&&console.log(`(raw) sending ${I} from ${c} to ${o}`),super.send(JSON.stringify({name:I,payload:g}))};super.readyState===1?Z():super.onopen=Z,setTimeout(()=>n(),C)})}},L=class l extends Function{constructor(I,g,C,c=""){return super(),this[y]=g,this[r]=C,this.id=cg(),this.path=c,this.socket=I,new Proxy(this,{get:(o,t)=>t==="id"?this.id:t==="socket"?this.socket:new l(I,g,C,`${c}:${t}`),apply:async(o,t,e)=>{d&&console.log(`[SPapply] sending ${this.path.substring(1)} receiver ${this[y]} to ${this[r]}`);let i=await this.socket.upgraded.send(this.path.substring(1),e);if(i instanceof R){let n=[...new Array(e.length)].map((b,Z)=>String.fromCharCode(97+Z)).join(",");throw d&&console.error(`ERROR calling [[${i.originName}]].${this.path.substring(1).replaceAll(":",".")}(${n}): ${i.message}`),new Error(i.message)}return i}})}};function N(l,I,g,C){return C=k.upgrade(C,g,l,I),C[f]=new L(C,l,I)}var h=!1,T=Symbol();function j(l){return class z extends l{static get disallowedCalls(){let g=Object.getOwnPropertyNames(z.prototype);return["constructor","disconnect"].forEach(C=>g.splice(g.indexOf(C),1)),g}constructor(){super();let g=this[T]={},C=new Proxy(g,{get:(c,o)=>g[o],set:()=>{throw new Error("cannot directly assign to state, use setState(update)")}});Object.defineProperty(this,"state",{value:C,writable:!1,configurable:!1}),this.onConnect||(this.onConnect=async()=>{h&&console.log(`[ClientBase] client ${this.state.id} connected.`)}),this.onDisconnect||(this.onDisconnect=async()=>{h&&console.log(`[ClientBase] client ${this.state.id} disconnected.`)}),this.onQuit||(this.onQuit=async()=>{h&&console.log(`[ClientBase] client ${this.state.id} quitting.`)})}setState(g){h&&console.log("[ClientBase] updating state");let C=this[T];Object.entries(g).forEach(([c,o])=>C[c]=o)}connectServerSocket(g){h&&console.log("[ClientBase]  connected to server"),this.server=N(p,v,this,g),this.onConnect()}disconnect(){this.server.socket.close()}}}function E(l){return class Q extends l{clients=[];ws=void 0;webserver=void 0;static get disallowedCalls(){let g=Object.getOwnPropertyNames(Q.prototype);return g.splice(g.indexOf("constructor"),1),g}constructor(g,C){super(),this.ws=g,this.webserver=C}async connectClientSocket(g){h&&console.log("[ServerBase] client connecting to server...");let C=N(v,p,this,g);h&&console.log("[ServerBase] sending connection id"),C.socket.send(JSON.stringify({name:"handshake:setid",payload:{id:C.id}})),h&&console.log("[ServerBase] adding client to list of known clients"),this.clients.push(C),this.addDisconnectHandling(C,g),this.onConnect(C)}async addDisconnectHandling(g,C){let{clients:c}=this;C.on("close",()=>{let o=c.findIndex(t=>t===g);if(o!==-1){let t=c.splice(o,1)[0];this.onDisconnect(g)}})}async onDisconnect(g){if(super.onDisconnect)return super.onDisconnect(g);h&&console.log(`[ServerBase] client ${g.id} disconnected.`)}async onConnect(g){if(super.onConnect)return super.onConnect(g);h&&console.log(`[ServerBase] client ${g.id} connected.`)}async quit(){await this.onQuit(),this.clients.forEach(g=>g.disconnect()),this.webserver.close(),this.ws.close(),this.teardown()}async onQuit(){if(super.onQuit)return super.onQuit();h&&console.log("[ServerBase] told to quit.")}async teardown(){if(super.teardown)return super.teardown();h&&console.log("[ServerBase] post-quit teardown.")}}}import{createPatch as og}from"rfc6902";var V=!1;function P(l){return class O extends l{browser=void 0;static get disallowedCalls(){let g=Object.getOwnPropertyNames(O.prototype).concat(l.disallowedCalls);return["constructor","quit","syncState"].forEach(C=>g.splice(g.indexOf(C),1)),g}connectBrowserSocket(g){this.browser||(this.browser=N(U,S,this,g),this.browser.socket.__seq_num=0,this.setState(this.state))}disconnectBrowserSocket(){this.browser=void 0}setState(g){if(V&&console.log("[WebClientBase] setState"),super.setState(g),V&&console.log("[WebClientBase] client has browser?",!!this.browser),this.browser){V&&console.log("[WebClientBase] creating diff as part of setState");let C=og(this.__oldState??{},this.state);if(C.length>0){let c={state:C,seq_num:++this.browser.socket.__seq_num,diff:!0};V&&console.log("[WebClientBase] sending diff as part of setState:",c),this.browser.socket.send(JSON.stringify(c))}else V&&console.log("no difference, skipping state sync.")}this.__oldState=JSON.parse(JSON.stringify(this.state))}syncState(){if(this.browser){V&&console.log("[WebClientBase] running syncState (will respond with full state)");let g=JSON.parse(JSON.stringify(this.state));return this.browser.socket.__seq_num=0,V&&console.log("[WebClientBase] responding with full state:",g),g}throw new Error("[WebClientBase] Cannot sync state: no browser attached to client.")}quit(){this.browser&&(this.browser.socket.close(),this.disconnectBrowserSocket()),this.disconnect(),this.onQuit()}}}var J=class{constructor(I){this.client=I,this.routes={}}addRouteHandler(I,g){this.routes[I]=g}handle(I,g,C){let c=this.routes[I];return c?(c(this.client,g,C),!0):!1}};import tg from"fs";import{join as M}from"path";var D=atob("CmNvbnN0IEJST1dTRVIgPSAiYnJvd3NlciI7CmNvbnN0IENMSUVOVCA9ICJjbGllbnQiOwoKY2xhc3MgUlBDRXJyb3IgewogIGNvbnN0cnVjdG9yKG9yaWdpbk5hbWUsIG1lc3NhZ2UpIHsKICAgIHRoaXMub3JpZ2luTmFtZSA9IG9yaWdpbk5hbWU7CiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogIH0KfQoKY29uc3QgREVCVUcgPSBmYWxzZTsKCi8vIGltcG9ydGluZyB0aGUgdXVpZCBwYWNrYWdlIGlzIHdheSB0b28gZXhwZW5zaXZlIGZvciB3aGF0IHdlIG5lZWQgaGVyZQpmdW5jdGlvbiB1dWlkKCkgewogIGNvbnN0IG5vdyA9IERhdGUubm93KCkudG9TdHJpbmcoMTYpOwogIGNvbnN0IHJkbSA9ICgoMWU2ICogTWF0aC5yYW5kb20oKSkgfCAwKS50b1N0cmluZygxNik7CiAgcmV0dXJuIGAke25vd30tJHtyZG19YDsKfQoKLy8gcmVzcG9uc2VzIHNob3VsZCBhbHdheXMgYmUgInRoZSBldmVudCBuYW1lLCB3aXRoIDpyZXNwb25zZSBhZGRlZCIKY29uc3QgUkVTUE9OU0VfU1VGRklYID0gYDpyZXNwb25zZWA7CmV4cG9ydCBjb25zdCBnZXRSZXNwb25zZU5hbWUgPSAoZXZlbnROYW1lKSA9PiBgJHtldmVudE5hbWV9JHtSRVNQT05TRV9TVUZGSVh9YDsKCi8vIHVzZSBzeW1ib2xzIHNvIHdlIGRvbid0IHBvbGx1dGUgdGhlIHNvY2tldCBwcm90b3R5cGUKY29uc3QgT1JJR0lOID0gU3ltYm9sKGBvcmlnaW5gKTsKY29uc3QgUFJPWFkgPSBTeW1ib2woYHByb3h5YCk7CmNvbnN0IFJFQ0VJVkVSID0gU3ltYm9sKGByZWNlaXZlcmApOwpjb25zdCBSRU1PVEUgPSBTeW1ib2woYHJlbW90ZWApOwpjb25zdCBIQU5ETEVSUyA9IFN5bWJvbChgaGFuZGxlcnNgKTsKCi8qKgogKiAuLi4KICovCmNsYXNzIFVwZ3JhZGVkU29ja2V0IGV4dGVuZHMgV2ViU29ja2V0IHsKICBbT1JJR0lOXSA9IHVuZGVmaW5lZDsgLy8gdGhlIHNvY2tldCBvd25lciB3aG8gaW52b2tlZCB0aGUgdXBncmFkZS4gU2VlIHVwZ3JhZGUoKQogIFtQUk9YWV0gPSB1bmRlZmluZWQ7IC8vIHRoZSBwcm94eSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc29ja2V0CiAgW1JFQ0VJVkVSXSA9IGBgOyAvLyBuYW1lIG9mIHRoZSByZWNlaXZpbmcgb2JqZWN0CiAgW1JFTU9URV0gPSBgYDsgLy8gbmFtZSBvZiB0aGUgcmVtb3RlIG9iamVjdAogIFtIQU5ETEVSU10gPSB7fTsgLy8gdGhlIGxpc3Qgb2YgZXZlbnQgaGFuZGxlcnMuIFNlZSB1cGdyYWRlKCkKCiAgLy8gZXhwbGljaXRseSBmb3JiaWQgdGhlIGNvbnN0cnVjdG9yIGZyb20gYmVpbmcgdXNlZC4KICAvLyBAdHMtaWdub3JlOiB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgc3VwZXIoKSBpZiB3ZSBlcnJvciBvdXQuCiAgY29uc3RydWN0b3IoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICJDYW5ub3QgY3JlYXRlIFVwZ3JhZGVkU29ja2V0IGluc3RhbmNlcy4gVXNlIFVwZ3JhZGVkU29ja2V0LnVwZ3JhZGUobmFtZSwgb3JpZ2luLCBzb2NrZXQpIGluc3RlYWQuIiwKICAgICk7CiAgfQoKICAvLyB1cGdyYWRlIGEgc29ja2V0IGZyb20gcGxhaW4gV2ViU29ja2V0IHRvIHRoaXMgY2xhc3MgaW5zdGVhZC4KICBzdGF0aWMgdXBncmFkZShzb2NrZXQsIG9yaWdpbiwgcmVjZWl2ZXIsIHJlbW90ZSkgewogICAgaWYgKHNvY2tldCBpbnN0YW5jZW9mIFVwZ3JhZGVkU29ja2V0KSByZXR1cm4gc29ja2V0OwogICAgLy8gdXBkYXRlIHRoZSBwcm90b3R5cGUgYmluZGluZwogICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHNvY2tldCwgVXBncmFkZWRTb2NrZXQucHJvdG90eXBlKTsKICAgIC8vIG1ha2Ugc3VyZSB0aGF0IG1lc3NhZ2VzIGdvIHRocm91Z2ggdGhlIHJvdXRlcjoKICAgIHNvY2tldFtPUklHSU5dID0gb3JpZ2luOwogICAgc29ja2V0W1JFQ0VJVkVSXSA9IHJlY2VpdmVyOwogICAgc29ja2V0W1JFTU9URV0gPSByZW1vdGU7CiAgICBzb2NrZXRbSEFORExFUlNdID0ge307CiAgICBjb25zdCBtZXNzYWdlUm91dGVyID0gc29ja2V0LnJvdXRlci5iaW5kKHNvY2tldCk7CiAgICBpZiAoc29ja2V0Lm9uKSB7CiAgICAgIHNvY2tldC5vbihgbWVzc2FnZWAsIG1lc3NhZ2VSb3V0ZXIpOwogICAgfSBlbHNlIHsKICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IG1lc3NhZ2VSb3V0ZXI7CiAgICB9CgogICAgLy8gY29udmVuaWVuY2UgcmV0dXJuLgogICAgcmV0dXJuIHNvY2tldDsKICB9CgogIC8vIFNwZWNpYWwgYWNjZXNzb3IgZm9yIHVwZ3JhZGVkIHNvY2tldCBmdW5jdGlvbnMsCiAgZ2V0IHVwZ3JhZGVkKCkgewogICAgaWYgKCF0aGlzLl9fdXBncmFkZWQpIHsKICAgICAgdGhpcy5fX3VwZ3JhZGVkID0gewogICAgICAgIG9uOiAoLi4uYXJncykgPT4gdGhpcy5fX29uKC4uLmFyZ3MpLAogICAgICAgIG9mZjogKC4uLmFyZ3MpID0+IHRoaXMuX19vZmYoLi4uYXJncyksCiAgICAgICAgc2VuZDogKC4uLmFyZ3MpID0+IHRoaXMuX19zZW5kKC4uLmFyZ3MpLAogICAgICB9OwogICAgfQogICAgcmV0dXJuIHRoaXMuX191cGdyYWRlZDsKICB9CgogIC8vIG1lc3NhZ2Ugcm91dGVyIHNwZWNpZmljYWxseSBmb3IgdGhlIG1lc3NhZ2UgZm9ybWF0IHVzZWQgYnkgdGhlIHNvY2tldGxlc3MgY29kZS4KICBhc3luYyByb3V0ZXIobWVzc2FnZSkgewogICAgY29uc3QgeyBbT1JJR0lOXTogb3JpZ2luLCBbUkVDRUlWRVJdOiByZWNlaXZlciwgW1JFTU9URV06IHJlbW90ZSB9ID0gdGhpczsKCiAgICAvLyBBbnkgY2FsbHMgZnJvbSB0aGUgYnJvd3NlciB0byB0aGUgd2ViY2xpZW50IGFyZSB0aGF0J3MgYWxyZWFkeSBoYW5kbGVkCiAgICAvLyBieSB0aGUgd2Vic29ja2V0IGRpcmVjdGx5IChzZWUgdGhlIGNyZWF0ZVdlYkNsaWVudCBmdW5jdGlvbiBpbiBpbmRleC5qcywKICAgIC8vIGluIHRoZSB3cy5vbihgY29ubmVjdGlvbmAsIC4uLikgYmxvY2spLCBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBub3QKICAgIC8vIHRyeSB0byAiZG91YmxlLWhhbmRsZSIgdGhhdDoKICAgIGlmIChyZW1vdGUgPT09IEJST1dTRVIpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIGJyb3dzZXIgd2Vic29ja2V0PyBJZiBzbywgdW53cmFwIHRoZSBkYXRhCiAgICBpZiAobWVzc2FnZS5zcmNFbGVtZW50KSB7CiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmRhdGE7CiAgICB9CgogICAgbGV0IGRhdGE7CgogICAgdHJ5IHsKICAgICAgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZSk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2Ugd2Vic29ja2V0IGRhdGE6ICR7bWVzc2FnZX1gKTsKICAgIH0KCiAgICBjb25zdCB7IG5hbWU6IGV2ZW50TmFtZSwgcGF5bG9hZCwgZXJyb3I6IGVycm9yTXNnLCBkaWZmLCBzZXFfbnVtIH0gPSBkYXRhOwogICAgbGV0IHsgc3RhdGUgfSA9IGRhdGE7CiAgICBsZXQgdGhyb3dhYmxlID0gZXJyb3JNc2cgPyBuZXcgUlBDRXJyb3IocmVjZWl2ZXIsIGVycm9yTXNnKSA6IHVuZGVmaW5lZDsKCiAgICBpZiAoREVCVUcpCiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZWNlaXZlcn1dL1ske3JlbW90ZX1dIHJvdXRlciBydW5uaW5nIGdpdmVuOmAsIHsKICAgICAgICBldmVudE5hbWUsCiAgICAgICAgcGF5bG9hZCwKICAgICAgICBlcnJvck1zZywKICAgICAgICBzdGF0ZSwKICAgICAgICBkaWZmLAogICAgICAgIHNlcV9udW0sCiAgICAgIH0pOwoKICAgIC8vIENsaWVudC1zdGF0ZSBzeW5jaHJvbml6YXRpb24gbWVjaGFuaXNtIGZvciB0aGUgYnJvd3NlcjoKICAgIGlmIChzdGF0ZSAmJiByZWNlaXZlciA9PT0gQlJPV1NFUikgewogICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKGBoYW5kbGluZyBzdGF0ZSB1cGRhdGUgaW4gdGhlIGJyb3dzZXJgLCBzdGF0ZSk7CiAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coYG9yaWdpbiBvYmplY3Q6YCwgeyBvcmlnaW4gfSk7CiAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luLnN0YXRlKSk7CiAgICAgIGlmIChkaWZmKSB7CiAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZyhgcmVjZWl2ZWQgZGlmZmAsIHN0YXRlKTsKICAgICAgICBjb25zdCBwYXRjaCA9IHN0YXRlOwogICAgICAgIGxldCB0YXJnZXQ7CiAgICAgICAgLy8gdmVyaWZ5IHdlJ3JlIHN0aWxsIGluIHN5bmMgYnkgY29tcGFyaW5nIG1lc3NhZ2luZyBzZXF1ZW5jZSBudW1iZXJzCiAgICAgICAgaWYgKHNlcV9udW0gPT09IG9yaWdpbi5fX3NlcV9udW0gKyAxKSB7CiAgICAgICAgICBvcmlnaW4uX19zZXFfbnVtID0gc2VxX251bTsKICAgICAgICAgIHRhcmdldCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJldlN0YXRlKSk7CiAgICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKGBhcHBseWluZyBwYXRjaCB0b2AsIHRhcmdldCk7CiAgICAgICAgICAvLyBAdHMtaWdub3JlOiB0aGlzIG9ubHkgcnVucyBpbiB0aGUgYnJvd3Nlciwgd2hlcmUgcmZjNjkwMiBpcyBhIGdsb2JhbC4KICAgICAgICAgIHJmYzY5MDIuYXBwbHlQYXRjaCh0YXJnZXQsIHBhdGNoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHdlJ3JlIG5vdCBpbiBzeW5jLCBhbmQgd2UgbmVlZCB0byByZXF1ZXN0IGEgZnVsbAogICAgICAgICAgLy8gc3RhdGUgb2JqZWN0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGFwcGx5IGRpZmZlcmVudGlhbCB1cGRhdGVzLgogICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZyhgc2VxX251bSBtaXNtYXRjaCwgc3luY2luZyBzdGF0ZWApOwogICAgICAgICAgY29uc3QgZnVsbFN0YXRlID0gYXdhaXQgdGhpcy5fX3NlbmQoYHN5bmNTdGF0ZWApOwogICAgICAgICAgb3JpZ2luLl9fc2VxX251bSA9IDA7CiAgICAgICAgICB0YXJnZXQgPSBmdWxsU3RhdGU7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gdGFyZ2V0OwogICAgICB9CiAgICAgIC8vIFJ1biB0aGUgdXBkYXRlIHdpdGggdGhlIG5ldyBzdGF0ZSBhcyBhcmd1bWVudCBmaXJzdCwgdGhlbgogICAgICAvLyBvdmVyd3JpdGUgdGhlIG9sZCBzdGF0ZSB3aXRoIHRoZSBuZXcgc3RhdGUgYWZ0ZXIgdGhlIHVwZGF0ZS4KICAgICAgb3JpZ2luLnN0YXRlID0gc3RhdGU7CiAgICAgIHJldHVybiBvcmlnaW4udXBkYXRlKHByZXZTdGF0ZSk7CiAgICB9CgogICAgLy8gSWYgdGhpcyBpcyBhIHJlc3BvbnNlIG1lc3NhZ2UsIHJ1biB0aGUgYG9uYCBoYW5kbGVyIGZvciB0aGF0LgogICAgaWYgKGV2ZW50TmFtZS5lbmRzV2l0aChSRVNQT05TRV9TVUZGSVgpKSB7CiAgICAgIGNvbnN0IHsgW0hBTkRMRVJTXTogaGFuZGxlcnMgfSA9IHRoaXM7CiAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coYFske3JlY2VpdmVyfV0gcmVzcG9uc2UgbWVzc2FnZSByZWNlaXZlZGApOwogICAgICBpZiAoIWhhbmRsZXJzW2V2ZW50TmFtZV0pIHRocm93IG5ldyBFcnJvcihgbm8gaGFuZGxlcnMgZm9yICR7ZXZlbnROYW1lfWApOwogICAgICBoYW5kbGVyc1tldmVudE5hbWVdLmZvckVhY2goKGhhbmRsZXIpID0+IHsKICAgICAgICBoYW5kbGVyKHRocm93YWJsZSA/IHRocm93YWJsZSA6IHBheWxvYWQpOwogICAgICB9KTsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGlzIGlzIGEgcmVhbCBSUEMgY2FsbCByYXRoZXIgdGhhbiBhIHJlc3BvbnNlIG9yIHN0YXRlIHVwZGF0ZS4KICAgIGlmIChwYXlsb2FkICYmICFBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICBgWyR7cmVjZWl2ZXJ9XSByZWNlaXZlZCBwYXlsb2FkIGZvciAke2V2ZW50TmFtZX0gZnJvbSBbJHtyZW1vdGV9XSBidXQgaXQgd2FzIG5vdCBhbiBhcnJheT8gJHtKU09OLnN0cmluZ2lmeSgKICAgICAgICAgIHBheWxvYWQsCiAgICAgICAgICBudWxsLAogICAgICAgICAgMiwKICAgICAgICApfWAsCiAgICAgICk7CiAgICB9CgogICAgLy8gSWYgaXQncyBhIHJlcXVlc3QgbWVzc2FnZSwgcmVzb2x2ZSBpdCB0byBhIGZ1bmN0aW9uIGNhbGwgYW5kICJyZXR1cm4iCiAgICAvLyB0aGUgdmFsdWUgYnkgc2VuZGluZyBhIDpyZXNwb25zZSBtZXNzYWdlIG92ZXIgdGhlIHdlYnNvY2tldCBpbnN0ZWFkLgogICAgY29uc3Qgc3RhZ2VzID0gZXZlbnROYW1lLnNwbGl0KGA6YCk7CiAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKGBbJHtyZWNlaXZlcn1dIHJvdXRlcjogc3RhZ2VzOmAsIHN0YWdlcyk7CgogICAgbGV0IGNhbGxhYmxlID0gb3JpZ2luOwogICAgbGV0IGZvcmJpZGRlbiA9IG9yaWdpbi5fX3Byb3RvX18/LmNvbnN0cnVjdG9yLmRpc2FsbG93ZWRDYWxscyA/PyBbXTsKICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDsKICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDsKCiAgICAvLyBGaW5kIHRoZSBhY3R1YWwgZnVuY3Rpb24gdG8gY2FsbAogICAgdHJ5IHsKICAgICAgY29uc3QgW2ZpcnN0XSA9IHN0YWdlczsKICAgICAgaWYgKHN0YWdlcy5sZW5ndGggPT09IDEgJiYgZm9yYmlkZGVuLmluY2x1ZGVzKGZpcnN0KSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBjYWxsOiAke2ZpcnN0fSBpcyBhIHByb3RlY3RlZCBtZXRob2RgKTsKICAgICAgfQogICAgICB3aGlsZSAoc3RhZ2VzLmxlbmd0aCkgewogICAgICAgIGNvbnN0IHN0YWdlID0gc3RhZ2VzLnNoaWZ0KCk7CiAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZyhgY2hlY2tpbmcgJHtzdGFnZX1gKTsKICAgICAgICBjYWxsYWJsZSA9IGNhbGxhYmxlW3N0YWdlXTsKICAgICAgfQogICAgICAvLyBJZiB0aGlzIGNvZGUgcnVucyBvbiB0aGUgc2VydmVyLCB0aGUgZnVuY3Rpb24gbmVlZHMgdG8gYmUKICAgICAgLy8gY2FsbGVkIHdpdGggdGhlIGNsaWVudCBwcm94eSBhcyBmaXJzdCBhcmd1bWVudC4KICAgICAgaWYgKHJlY2VpdmVyID09PSBgc2VydmVyYCkgcGF5bG9hZC51bnNoaWZ0KHRoaXNbUFJPWFldKTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgLy8gImZ1bmN0aW9uIG5vdCBmb3VuZCIgZG9lc24ndCBjb3VudCBhcyBlcnJvciAiaGVyZSIuCiAgICAgIC8vIEluc3RlYWQsIHdlIHNlbmQgdGhhdCBiYWNrIHRvIHRoZSBjYWxsZXIuCiAgICAgIGlmIChERUJVRykgY29uc29sZS5lcnJvcihgY2Fubm90IHJlc29sdmUgJHtldmVudE5hbWV9IG9uICR7cmVjZWl2ZXJ9YCwgZSk7CiAgICAgIGVycm9yID0gZS5tZXNzYWdlOwogICAgfQoKICAgIC8vIFJlc29sdmUgdGhlIGZ1bmN0aW9uIGFuZCB0aGVuIHNlbmQgdGhlIHJlc3VsdCBhcyA6cmVzcG9uc2UsIG1ha2luZwogICAgLy8gc3VyZSB0byB0YWtlIGludG8gYWNjb3VudCB0aGF0IGEgY2FsbCBpdHNlbGYgbWlnaHQgdGhyb3cuCiAgICBpZiAoIWVycm9yKSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmVzcG9uc2UgPSAoYXdhaXQgY2FsbGFibGUuYmluZChvcmlnaW4pKC4uLnBheWxvYWQpKSA/PyB0cnVlOwogICAgICAgIC8vIElmIHRoaXMgaXMgYSB3ZWJjbGllbnQsIGFuZCB0aGVyZSBpcyBhIGJyb3dzZXIgY29ubmVjdGVkLAogICAgICAgIC8vIGFsc28gbWFrZSBzdXJlIHRvIHRyaWdnZXIgYSBzdGF0ZSBzeW5jLCBzbyB0aGF0IGNsaWVudCBjb2RlCiAgICAgICAgLy8gZG9lcyBub3QgbmVlZCB0byBpbmNsdWRlIHNldFN0YXRlIGNhbGxzIGFsbCBvdmVyIHRoZSBwbGFjZS4KICAgICAgICBpZiAocmVjZWl2ZXIgPT09IENMSUVOVCAmJiBvcmlnaW4uYnJvd3NlcikgewogICAgICAgICAgb3JpZ2luLnNldFN0YXRlKG9yaWdpbi5zdGF0ZSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKERFQlVHKQogICAgICAgICAgY29uc29sZS5lcnJvcigKICAgICAgICAgICAgYGZ1bmN0aW9uIGludm9jYXRpb24gZm9yICR7ZXZlbnROYW1lfSBmYWlsZWQgb24gJHtyZWNlaXZlcn0sIHBheWxvYWQ6YCwKICAgICAgICAgICAgcGF5bG9hZCwKICAgICAgICAgICk7CiAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmVycm9yKGUpOwogICAgICAgIGVycm9yID0gZS5tZXNzYWdlOwogICAgICB9CiAgICB9CgogICAgLy8gU2VuZCBvZmYgYSByZXNwb25zZSBtZXNzYWdlIHdpdGggZWl0aGVyIHRoZSByZXN1bHQsIG9yIHRoZSBlcnJvci4KICAgIGNvbnN0IHJlc3BvbnNlTmFtZSA9IGdldFJlc3BvbnNlTmFtZShldmVudE5hbWUpOwogICAgaWYgKERFQlVHKQogICAgICBjb25zb2xlLmxvZyhgWyR7cmVjZWl2ZXJ9XSBzZW5kaW5nICR7cmVzcG9uc2VOYW1lfWAsIHsKICAgICAgICBwYXlsb2FkOiByZXNwb25zZSwKICAgICAgICBlcnJvciwKICAgICAgfSk7CiAgICBzdXBlci5zZW5kKAogICAgICBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IHJlc3BvbnNlTmFtZSwgcGF5bG9hZDogcmVzcG9uc2UsIGVycm9yIH0pLAogICAgKTsKICB9CgogIC8qKgogICAqIHRoaXMudXBncmFkZWQub24oKSBtYWRlIHRvIHdvcmsgbGlrZSAuYWRkRXZlbnRMaXN0ZW5lcigpCiAgICovCiAgX19vbihldmVudE5hbWUsIGhhbmRsZXIpIHsKICAgIGNvbnN0IHsgW0hBTkRMRVJTXTogaGFuZGxlcnMgfSA9IHRoaXM7CiAgICBpZiAoIWhhbmRsZXJzW2V2ZW50TmFtZV0pIGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTsKICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTsKICAgIC8vIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyAib2ZmIiBmdW5jdGlvbiwgZm9yIGNvbnZlbmllbmNlLgogICAgcmV0dXJuICgpID0+IHRoaXMuX19vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTsKICB9CgogIC8qKgogICAqIHRoaXMudXBncmFkZWQub2ZmKCkgbWFkZSB0byB3b3JrIGxpa2UgLnJlbW92ZUV2ZW50TGlzdGVuZXIoKQogICAqLwogIF9fb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikgewogICAgY29uc3QgeyBbSEFORExFUlNdOiBoYW5kbGVycyB9ID0gdGhpczsKICAgIGlmICghaGFuZGxlcnNbZXZlbnROYW1lXSkgcmV0dXJuOwogICAgY29uc3QgcG9zID0gaGFuZGxlcnNbZXZlbnROYW1lXS5pbmRleE9mKGhhbmRsZXIpOwogICAgaGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UocG9zLCAxKTsKICB9CgogIC8qKgogICAqIEFkZCBhIHByb21pc2UtYmFzZWQgZW1pdC9yZWNlaXZlIHRvIHRoZSBzb2NrZXQsIHNvIHRoYXQgY2FsbGluZyBjb2RlIGNhbiBgYXdhaXRgIHRoZSByZXNwb25zZS4KICAgKgogICAqIE5vdGUgdGhhdCB0aGVyZSBpcyBhbiBvcHRpb25hbCB0aGlyZCBhcmd1bWVudCBgdGltZW91dGAgdGhhdCBjYW4gYmUgdXNlZCB0byBzYXkgaG93IGxvbmcgdGhlCiAgICogZW1pdCBzaG91bGQgd2FpdCBiZWZvcmUgZGVjaWRpbmcgdGhlcmUgaXMgbm8gcmVzcG9uc2UgZm9ydGhjb21pbmcgYW5kIHRvIGNsZWFuIHVwIHRoZSBldmVudAogICAqIGxpc3RlbmVyIGZvciB0aGF0IHJlc3BvbnNlLiBUaGUgZGVmYXVsdCB0aW1lb3V0IGlzIDEwMDBtcy4KICAgKi8KICBhc3luYyBfX3NlbmQoZXZlbnROYW1lLCBkYXRhID0ge30sIHRpbWVvdXQgPSAxMDAwKSB7CiAgICBjb25zdCB7IFtSRUNFSVZFUl06IHJlY2VpdmVyLCBbUkVNT1RFXTogcmVtb3RlIH0gPSB0aGlzOwogICAgaWYgKERFQlVHKQogICAgICBjb25zb2xlLmxvZyhgWyR7cmVjZWl2ZXJ9XSBzZW5kaW5nIFske2V2ZW50TmFtZX1dIHRvIFske3JlbW90ZX1dOmAsIGRhdGEpOwogICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgY29uc3QgcmVzcG9uc2VOYW1lID0gZ2V0UmVzcG9uc2VOYW1lKGV2ZW50TmFtZSk7CgogICAgICAvLyBjbGVhbnVwIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQgbGlzdGVuZXIKICAgICAgbGV0IGNsZWFudXAgPSAoZGF0YSA9IHVuZGVmaW5lZCkgPT4gewogICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coYFske3JlY2VpdmVyfV0gY2xlYW51cGApOwogICAgICAgIC8vIGNsZWFuIHVwIGFuZCBiZWNvbWUgYSBub29wIHNvIHdlIGNhbid0IGJlIHJldHJpZ2dlcmVkLgogICAgICAgIHRoaXMuX19vZmYocmVzcG9uc2VOYW1lLCBoYW5kbGVyKTsKICAgICAgICBjbGVhbnVwID0gKCkgPT4ge307CiAgICAgICAgcmVzb2x2ZShkYXRhKTsKICAgICAgfTsKCiAgICAgIC8vIEluIG9yZGVyIHRvIHJlc29sdmUgdGhlIFByb21pc2UsIHdlIHdpbGwgYmUgbGlzdGVuaW5nCiAgICAgIC8vIGZvciB0aGF0IGV2ZW50TmFtZTpyZXNwb25zZSwgYW5kIHdoZW4gd2UgcmVjZWl2ZSBpdCwKICAgICAgLy8gd2UnbGwgaW1tZWRpYXRlbHkgU1RPUCBsaXN0ZW5pbmcgZm9yIHNpbWlsYXIgcmVzcG9uc2VzCiAgICAgIC8vIGJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGNhcmUuCiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZGF0YSkgPT4gY2xlYW51cChkYXRhKTsKCiAgICAgIC8vIEZpcnN0LCBtYWtlIHN1cmUgd2UncmUgcmVhZHkgdG8gcmVjZWl2ZSB0aGUgcmVzcG9uc2UuLi4KICAgICAgdGhpcy5fX29uKHJlc3BvbnNlTmFtZSwgKGRhdGEpID0+IHsKICAgICAgICBpZiAoREVCVUcpCiAgICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgICAgYFske3JlY2VpdmVyfV0gaGFuZGxpbmcgcmVzcG9uc2UgZm9yICR7ZXZlbnROYW1lfSBmcm9tIFske3JlbW90ZX1dOmAsCiAgICAgICAgICApOwogICAgICAgIGhhbmRsZXIoZGF0YSk7CiAgICAgIH0pOwoKICAgICAgLy8gQW5kIHRoZW4sIHNlbmQgdGhlIGV2ZW50IG9mZiB0byB0aGUgY2xpZW50LgogICAgICBjb25zdCBzZW5kRXZlbnQgPSAoKSA9PiB7CiAgICAgICAgaWYgKERFQlVHKQogICAgICAgICAgY29uc29sZS5sb2coCiAgICAgICAgICAgIGAocmF3KSBzZW5kaW5nICR7ZXZlbnROYW1lfSBmcm9tICR7cmVjZWl2ZXJ9IHRvICR7cmVtb3RlfWAsCiAgICAgICAgICApOwogICAgICAgIHN1cGVyLnNlbmQoCiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSwKICAgICAgICAgICAgcGF5bG9hZDogZGF0YSwKICAgICAgICAgIH0pLAogICAgICAgICk7CiAgICAgIH07CgogICAgICAvLyBXZSBtYXkgYmUgdHJ5aW5nIHRvIHNlbmQgYmVmb3JlIHRoZSBzb2NrZXQgaXMgb3BlbiBpbiBicm93c2VyIGxhbmQsCiAgICAgIC8vIHNvIGlmIHRoZSBzb2NrZXQncyBub3QgcmVhZHksICJxdWV1ZSIgdGhlIGV2ZW50IHRvIGZpcmUgb24gb3Blbi4KICAgICAgaWYgKHN1cGVyLnJlYWR5U3RhdGUgPT09IDEpIHNlbmRFdmVudCgpOwogICAgICBlbHNlIHN1cGVyLm9ub3BlbiA9IHNlbmRFdmVudDsKCiAgICAgIC8vIEFuZCBtYWtlIHN1cmUgdGhhdCBpZiBubyByZXNwb25zZSBoYXMgb2NjdXJyZWQgd2l0aGluCiAgICAgIC8vIGB0aW1lb3V0YCBtaWxsaXNlY29uZHMsIHdlIGNsZWFuIHVwIHRoZSBsaXN0ZW5lci4KICAgICAgc2V0VGltZW91dCgoKSA9PiBjbGVhbnVwKCksIHRpbWVvdXQpOwogICAgfSk7CiAgfQp9CgovKioKICogQSBzb2NrZXQgcHJveHkgZm9yIFJQQyBwdXJwb3Nlcy4KICovCmNsYXNzIFNvY2tldFByb3h5IGV4dGVuZHMgRnVuY3Rpb24gewogIGNvbnN0cnVjdG9yKHNvY2tldCwgcmVjZWl2ZXIsIHJlbW90ZSwgcGF0aCA9IGBgKSB7CiAgICBzdXBlcigpOwogICAgdGhpc1tSRUNFSVZFUl0gPSByZWNlaXZlcjsKICAgIHRoaXNbUkVNT1RFXSA9IHJlbW90ZTsKICAgIHRoaXMuaWQgPSB1dWlkKCk7CiAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7CiAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHsKICAgICAgZ2V0OiAoXywgcHJvcCkgPT4gewogICAgICAgIGlmIChwcm9wID09PSAiaWQiKSByZXR1cm4gdGhpcy5pZDsKICAgICAgICBpZiAocHJvcCA9PT0gInNvY2tldCIpIHJldHVybiB0aGlzLnNvY2tldDsKICAgICAgICAvLyBAdHMtaWdub3JlOiB3ZSdyZSBuZXZlciBpbnZva2luZyB0aGlzIHdpdGggU3ltYm9sIGFzIHNlY29uZCBhcmd1bWVudAogICAgICAgIHJldHVybiBuZXcgU29ja2V0UHJveHkoc29ja2V0LCByZWNlaXZlciwgcmVtb3RlLCBgJHtwYXRofToke3Byb3B9YCk7CiAgICAgIH0sCiAgICAgIGFwcGx5OiBhc3luYyAoXywgX18sIGFyZ3MpID0+IHsKICAgICAgICBpZiAoREVCVUcpCiAgICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgICAgYFtTUGFwcGx5XSBzZW5kaW5nICR7dGhpcy5wYXRoLnN1YnN0cmluZygxKX0gcmVjZWl2ZXIgJHsKICAgICAgICAgICAgICB0aGlzW1JFQ0VJVkVSXQogICAgICAgICAgICB9IHRvICR7dGhpc1tSRU1PVEVdfWAsCiAgICAgICAgICApOwogICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNvY2tldC51cGdyYWRlZC5zZW5kKAogICAgICAgICAgdGhpcy5wYXRoLnN1YnN0cmluZygxKSwKICAgICAgICAgIGFyZ3MsCiAgICAgICAgKTsKICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFJQQ0Vycm9yKSB7CiAgICAgICAgICBjb25zdCBhcmdzdHIgPSBbLi4ubmV3IEFycmF5KGFyZ3MubGVuZ3RoKV0KICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIGkpKQogICAgICAgICAgICAuam9pbihgLGApOwogICAgICAgICAgaWYgKERFQlVHKQogICAgICAgICAgICBjb25zb2xlLmVycm9yKAogICAgICAgICAgICAgIGBFUlJPUiBjYWxsaW5nIFtbJHtkYXRhLm9yaWdpbk5hbWV9XV0uJHt0aGlzLnBhdGgKICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMSkKICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKGA6YCwgYC5gKX0oJHthcmdzdHJ9KTogJHtkYXRhLm1lc3NhZ2V9YCwKICAgICAgICAgICAgKTsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgfSwKICAgIH0pOwogIH0KfQoKLyoqCiAqIC4uZG9jcyBnbyBoZXJlLi4uCiAqIEBwYXJhbSB7c3RyaW5nfSByZWNlaXZlcgogKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlCiAqIEBwYXJhbSB7Kn0gb3JpZ2luCiAqIEBwYXJhbSB7Kn0gc29ja2V0CiAqIEByZXR1cm5zCiAqLwpmdW5jdGlvbiBwcm94eVNvY2tldChyZWNlaXZlciwgcmVtb3RlLCBvcmlnaW4sIHNvY2tldCkgewogIHNvY2tldCA9IFVwZ3JhZGVkU29ja2V0LnVwZ3JhZGUoc29ja2V0LCBvcmlnaW4sIHJlY2VpdmVyLCByZW1vdGUpOwogIHJldHVybiAoc29ja2V0W1BST1hZXSA9IG5ldyBTb2NrZXRQcm94eShzb2NrZXQsIHJlY2VpdmVyLCByZW1vdGUpKTsKfQoKCiAgICBleHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViQ2xpZW50KFdlYkNsaWVudENsYXNzKSB7CiAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXQod2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkucmVwbGFjZSgiaHR0cCIsICJ3cyIpKTsKICAgICAgY29uc3QgYnJvd3NlckNsaWVudCA9IG5ldyBXZWJDbGllbnRDbGFzcygpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnJvd3NlckNsaWVudCwgInNvY2tldCIsIHsKICAgICAgICB2YWx1ZTogc29ja2V0LAogICAgICAgIHdyaXRhYmxlOiBmYWxzZSwKICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLAogICAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnJvd3NlckNsaWVudCwgInNlcnZlciIsIHsKICAgICAgICB2YWx1ZTogcHJveHlTb2NrZXQoImJyb3dzZXIiLCAid2ViY2xpZW50IiwgYnJvd3NlckNsaWVudCwgc29ja2V0KSwKICAgICAgICB3cml0YWJsZTogZmFsc2UsCiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJyb3dzZXJDbGllbnQsICJxdWl0IiwgewogICAgICAgIHZhbHVlOiAoKSA9PiBicm93c2VyQ2xpZW50LnNlcnZlci5kaXNjb25uZWN0KCkKICAgICAgfSk7CiAgICAgIGJyb3dzZXJDbGllbnQuc3RhdGUgPSB7fTsKICAgICAgYnJvd3NlckNsaWVudC5pbml0KCk7CiAgICAgIHJldHVybiBicm93c2VyQ2xpZW50OwogICAgfTsKICAKKGZ1bmN0aW9uKHAscil7Im9iamVjdCI9PT10eXBlb2YgZXhwb3J0cyYmInVuZGVmaW5lZCIhPT10eXBlb2YgbW9kdWxlP3IoZXhwb3J0cyk6ImZ1bmN0aW9uIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiZXhwb3J0cyJdLHIpOihwPSJ1bmRlZmluZWQiIT09dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpwfHxzZWxmLHIocC5yZmM2OTAyPXt9KSl9KSh0aGlzLGZ1bmN0aW9uKHApe2Z1bmN0aW9uIHIoYSl7cmV0dXJuIGEucmVwbGFjZSgvfjEvZywiLyIpLnJlcGxhY2UoL34wL2csIn4iKX1mdW5jdGlvbiBFKGEpe3JldHVybiBhLnJlcGxhY2UoL34vZywifjAiKS5yZXBsYWNlKC9cLy9nLCJ+MSIpfWZ1bmN0aW9uIHooYSl7cmV0dXJuIHZvaWQgMD09PWE/InVuZGVmaW5lZCI6bnVsbD09PWE/Im51bGwiOkFycmF5LmlzQXJyYXkoYSk/ImFycmF5Ijp0eXBlb2YgYX1mdW5jdGlvbiB2KGEpe2lmKG51bGw9PWF8fCJvYmplY3QiIT10eXBlb2YgYSlyZXR1cm4gYTsKaWYoYS5jb25zdHJ1Y3Rvcj09QXJyYXkpe3ZhciBiPWEubGVuZ3RoLGM9QXJyYXkoYik7Zm9yKGxldCBkPTA7ZDxiO2QrKyljW2RdPXYoYVtkXSk7cmV0dXJuIGN9aWYoYS5jb25zdHJ1Y3Rvcj09RGF0ZSlyZXR1cm4gbmV3IERhdGUoK2EpO2I9e307Zm9yKGMgaW4gYSl3LmNhbGwoYSxjKSYmKGJbY109dihhW2NdKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gRih7b3A6YX0pe3JldHVybiJyZW1vdmUiPT09YXx8InJlcGxhY2UiPT09YXx8ImNvcHkiPT09YXx8Im1vdmUiPT09YX1mdW5jdGlvbiBBKGEsYil7Y29uc3QgYz17fTtmb3IoY29uc3QgZCBpbiBhKXcuY2FsbChhLGQpJiZ2b2lkIDAhPT1hW2RdJiYoY1tkXT0xKTtmb3IoY29uc3QgZCBpbiBiKXcuY2FsbChiLGQpJiZ2b2lkIDAhPT1iW2RdJiZkZWxldGUgY1tkXTtyZXR1cm4gT2JqZWN0LmtleXMoYyl9ZnVuY3Rpb24gRyhhKXtjb25zdCBiPWEubGVuZ3RoLGM9e307Zm9yKGxldCBkPTA7ZDxiO2QrKyl7Y29uc3QgZT1hW2RdO2Zvcihjb25zdCBmIGluIGUpdy5jYWxsKGUsCmYpJiZ2b2lkIDAhPT1lW2ZdJiYoY1tmXT0oY1tmXXx8MCkrMSl9Zm9yKGNvbnN0IGQgaW4gYyljW2RdPGImJmRlbGV0ZSBjW2RdO3JldHVybiBPYmplY3Qua2V5cyhjKX1mdW5jdGlvbiB4KGEsYil7cmV0dXJue29wZXJhdGlvbnM6YS5vcGVyYXRpb25zLmNvbmNhdChiKSxjb3N0OmEuY29zdCsxfX1mdW5jdGlvbiBIKGEsYixjLGQ9cSl7ZnVuY3Rpb24gZShrLGcpe2NvbnN0IGg9YCR7a30sJHtnfWA7dmFyIGw9ZltoXTtpZih2b2lkIDA9PT1sKXtpZigwPGsmJjA8ZyYmIWQoYVtrLTFdLGJbZy0xXSxjLmFkZChTdHJpbmcoay0xKSkpLmxlbmd0aClsPWUoay0xLGctMSk7ZWxzZXtsPVtdO2lmKDA8ayl7dmFyIHQ9ZShrLTEsZyk7bC5wdXNoKHgodCx7b3A6InJlbW92ZSIsaW5kZXg6ay0xfSkpfTA8ZyYmKHQ9ZShrLGctMSksbC5wdXNoKHgodCx7b3A6ImFkZCIsaW5kZXg6ay0xLHZhbHVlOmJbZy0xXX0pKSk7MDxrJiYwPGcmJih0PWUoay0xLGctMSksbC5wdXNoKHgodCx7b3A6InJlcGxhY2UiLAppbmRleDprLTEsb3JpZ2luYWw6YVtrLTFdLHZhbHVlOmJbZy0xXX0pKSk7bD1sLnNvcnQoKEksSik9PkkuY29zdC1KLmNvc3QpWzBdfWZbaF09bH1yZXR1cm4gbH1jb25zdCBmPXsiMCwwIjp7b3BlcmF0aW9uczpbXSxjb3N0OjB9fSxCPWlzTmFOKGEubGVuZ3RoKXx8MD49YS5sZW5ndGg/MDphLmxlbmd0aDt2YXIgdT1pc05hTihiLmxlbmd0aCl8fDA+PWIubGVuZ3RoPzA6Yi5sZW5ndGg7dT1lKEIsdSkub3BlcmF0aW9ucztbdV09dS5yZWR1Y2UoKFtrLGddLGgpPT57aWYoImFkZCI9PT1oLm9wKXt2YXIgbD1oLmluZGV4KzErZztoPXtvcDpoLm9wLHBhdGg6Yy5hZGQobDxCK2c/U3RyaW5nKGwpOiItIikudG9TdHJpbmcoKSx2YWx1ZTpoLnZhbHVlfTtyZXR1cm5bay5jb25jYXQoaCksZysxXX1pZigicmVtb3ZlIj09PWgub3ApcmV0dXJuIGg9e29wOmgub3AscGF0aDpjLmFkZChTdHJpbmcoaC5pbmRleCtnKSkudG9TdHJpbmcoKX0sW2suY29uY2F0KGgpLGctMV07bD1jLmFkZChTdHJpbmcoaC5pbmRleCsKZykpO2g9ZChoLm9yaWdpbmFsLGgudmFsdWUsbCk7cmV0dXJuW2suY29uY2F0KC4uLmgpLGddfSxbW10sMF0pO3JldHVybiB1fWZ1bmN0aW9uIEsoYSxiLGMsZD1xKXtjb25zdCBlPVtdO0EoYSxiKS5mb3JFYWNoKGY9PntlLnB1c2goe29wOiJyZW1vdmUiLHBhdGg6Yy5hZGQoZikudG9TdHJpbmcoKX0pfSk7QShiLGEpLmZvckVhY2goZj0+e2UucHVzaCh7b3A6ImFkZCIscGF0aDpjLmFkZChmKS50b1N0cmluZygpLHZhbHVlOmJbZl19KX0pO0coW2EsYl0pLmZvckVhY2goZj0+e2UucHVzaCguLi5kKGFbZl0sYltmXSxjLmFkZChmKSkpfSk7cmV0dXJuIGV9ZnVuY3Rpb24gcShhLGIsYyxkPXEpe2lmKGE9PT1iKXJldHVybltdO2NvbnN0IGU9eihhKSxmPXooYik7cmV0dXJuImFycmF5Ij09ZSYmImFycmF5Ij09Zj9IKGEsYixjLGQpOiJvYmplY3QiPT1lJiYib2JqZWN0Ij09Zj9LKGEsYixjLGQpOlt7b3A6InJlcGxhY2UiLHBhdGg6Yy50b1N0cmluZygpLHZhbHVlOmJ9XX1mdW5jdGlvbiB5KGEsCmIsYyl7QXJyYXkuaXNBcnJheShhKT8iLSI9PWI/YS5wdXNoKGMpOihiPXBhcnNlSW50KGIsMTApLGEuc3BsaWNlKGIsMCxjKSk6YVtiXT1jfWZ1bmN0aW9uIEMoYSxiKXtBcnJheS5pc0FycmF5KGEpPyhiPXBhcnNlSW50KGIsMTApLGEuc3BsaWNlKGIsMSkpOmRlbGV0ZSBhW2JdfWZ1bmN0aW9uIEwoYSxiKXthPW0uZnJvbUpTT04oYi5wYXRoKS5ldmFsdWF0ZShhKTtpZihudWxsPT09YS5wYXJlbnQpcmV0dXJuIG5ldyBuKGIucGF0aCk7aWYoQXJyYXkuaXNBcnJheShhLnBhcmVudCkpe2lmKHBhcnNlSW50KGEua2V5LDEwKT49YS5wYXJlbnQubGVuZ3RoKXJldHVybiBuZXcgbihiLnBhdGgpfWVsc2UgaWYodm9pZCAwPT09YS52YWx1ZSlyZXR1cm4gbmV3IG4oYi5wYXRoKTthLnBhcmVudFthLmtleV09Yi52YWx1ZTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBNKGEsYil7c3dpdGNoKGIub3Ape2Nhc2UgImFkZCI6cmV0dXJuIGE9bS5mcm9tSlNPTihiLnBhdGgpLmV2YWx1YXRlKGEpLHZvaWQgMD09PQphLnBhcmVudD9iPW5ldyBuKGIucGF0aCk6KHkoYS5wYXJlbnQsYS5rZXksdihiLnZhbHVlKSksYj1udWxsKSxiO2Nhc2UgInJlbW92ZSI6cmV0dXJuIGE9bS5mcm9tSlNPTihiLnBhdGgpLmV2YWx1YXRlKGEpLHZvaWQgMD09PWEudmFsdWU/Yj1uZXcgbihiLnBhdGgpOihDKGEucGFyZW50LGEua2V5KSxiPW51bGwpLGI7Y2FzZSAicmVwbGFjZSI6cmV0dXJuIEwoYSxiKTtjYXNlICJtb3ZlIjp2YXIgYz1tLmZyb21KU09OKGIuZnJvbSkuZXZhbHVhdGUoYSk7dm9pZCAwPT09Yy52YWx1ZT9iPW5ldyBuKGIuZnJvbSk6KGE9bS5mcm9tSlNPTihiLnBhdGgpLmV2YWx1YXRlKGEpLHZvaWQgMD09PWEucGFyZW50P2I9bmV3IG4oYi5wYXRoKTooQyhjLnBhcmVudCxjLmtleSkseShhLnBhcmVudCxhLmtleSxjLnZhbHVlKSxiPW51bGwpKTtyZXR1cm4gYjtjYXNlICJjb3B5IjpyZXR1cm4gYz1tLmZyb21KU09OKGIuZnJvbSkuZXZhbHVhdGUoYSksdm9pZCAwPT09Yy52YWx1ZT9iPW5ldyBuKGIuZnJvbSk6CihhPW0uZnJvbUpTT04oYi5wYXRoKS5ldmFsdWF0ZShhKSx2b2lkIDA9PT1hLnBhcmVudD9iPW5ldyBuKGIucGF0aCk6KHkoYS5wYXJlbnQsYS5rZXksdihjLnZhbHVlKSksYj1udWxsKSksYjtjYXNlICJ0ZXN0IjpyZXR1cm4gYT1tLmZyb21KU09OKGIucGF0aCkuZXZhbHVhdGUoYSksYj1xKGEudmFsdWUsYi52YWx1ZSxuZXcgbSkubGVuZ3RoP25ldyBOKGEudmFsdWUsYi52YWx1ZSk6bnVsbCxifXJldHVybiBuZXcgTyhiKX1mdW5jdGlvbiBQKGEpe2Z1bmN0aW9uIGIoYyxkLGUpe2NvbnN0IGY9YShjLGQsZSk7cmV0dXJuIEFycmF5LmlzQXJyYXkoZik/ZjpxKGMsZCxlLGIpfXJldHVybiBifWZ1bmN0aW9uIEQoYSxiKXthPW0uZnJvbUpTT04oYikuZXZhbHVhdGUoYSk7aWYodm9pZCAwIT09YSlyZXR1cm57b3A6InRlc3QiLHBhdGg6Yix2YWx1ZTphLnZhbHVlfX1jbGFzcyBte2NvbnN0cnVjdG9yKGE9WyIiXSl7dGhpcy50b2tlbnM9YX1zdGF0aWMgZnJvbUpTT04oYSl7Y29uc3QgYj0KYS5zcGxpdCgiLyIpLm1hcChyKTtpZigiIiE9PWJbMF0pdGhyb3cgRXJyb3IoYEludmFsaWQgSlNPTiBQb2ludGVyOiAke2F9YCk7cmV0dXJuIG5ldyBtKGIpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMudG9rZW5zLm1hcChFKS5qb2luKCIvIil9ZXZhbHVhdGUoYSl7bGV0IGI9bnVsbCxjPSIiO2ZvcihsZXQgZD0xLGU9dGhpcy50b2tlbnMubGVuZ3RoO2Q8ZTtkKyspYj1hLGM9dGhpcy50b2tlbnNbZF0sIl9fcHJvdG9fXyIhPWMmJiJjb25zdHJ1Y3RvciIhPWMmJiJwcm90b3R5cGUiIT1jJiYoYT0oYnx8e30pW2NdKTtyZXR1cm57cGFyZW50OmIsa2V5OmMsdmFsdWU6YX19Z2V0KGEpe3JldHVybiB0aGlzLmV2YWx1YXRlKGEpLnZhbHVlfXNldChhLGIpe2ZvcihsZXQgYz0xLGQ9dGhpcy50b2tlbnMubGVuZ3RoLTEsZT10aGlzLnRva2Vuc1tjXTtjPGQ7YysrKWE9KGF8fHt9KVtlXTthJiYoYVt0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGgtMV1dPWIpfXB1c2goYSl7dGhpcy50b2tlbnMucHVzaChhKX1hZGQoYSl7YT0KdGhpcy50b2tlbnMuY29uY2F0KFN0cmluZyhhKSk7cmV0dXJuIG5ldyBtKGEpfX1jb25zdCB3PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7Y2xhc3MgbiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGEpe3N1cGVyKGBWYWx1ZSByZXF1aXJlZCBhdCBwYXRoOiAke2F9YCk7dGhpcy5wYXRoPWE7dGhpcy5uYW1lPSJNaXNzaW5nRXJyb3IifX1jbGFzcyBOIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoYSxiKXtzdXBlcihgVGVzdCBmYWlsZWQ6ICR7YX0gIT0gJHtifWApO3RoaXMuYWN0dWFsPWE7dGhpcy5leHBlY3RlZD1iO3RoaXMubmFtZT0iVGVzdEVycm9yIn19Y2xhc3MgTyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGEpe3N1cGVyKGBJbnZhbGlkIG9wZXJhdGlvbjogJHthLm9wfWApO3RoaXMub3BlcmF0aW9uPWE7dGhpcy5uYW1lPSJJbnZhbGlkT3BlcmF0aW9uRXJyb3IifX1wLmFwcGx5UGF0Y2g9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5tYXAoYz0+TShhLGMpKX07CnAuY3JlYXRlUGF0Y2g9ZnVuY3Rpb24oYSxiLGMpe2NvbnN0IGQ9bmV3IG07cmV0dXJuKGM/UChjKTpxKShhLGIsZCl9O3AuY3JlYXRlVGVzdHM9ZnVuY3Rpb24oYSxiKXtjb25zdCBjPVtdO2IuZmlsdGVyKEYpLmZvckVhY2goZD0+e2NvbnN0IGU9RChhLGQucGF0aCk7ZSYmYy5wdXNoKGUpOyJmcm9tImluIGQmJihkPUQoYSxkLmZyb20pKSYmYy5wdXNoKGQpfSk7cmV0dXJuIGN9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0pOwo=");var _={".html":"text/html",".css":"text/css",".js":"application/javascript",".jpg":"image/jpeg",".png":"image/png"},ng="text/plain";function $(l){let I=Object.keys(_).find(C=>l.slice(-C.length)===C);return _[I]||ng}function eg(l,I){return l==="/"?M(I,"index.html"):(l=l.substring(1),l=l.replace(/\.\./g,"").replace(/\/\//g,"/"),l=M(I,l),l)}function ig(l,I){console.error(`Can't serve ${l}, so it probably doesn't exist`),I.writeHead(404,{"Content-Type":"text/html"}),I.end("<doctype html><html><body>resource not found</html>")}function q(l,I){return(g,C)=>{if(g.url.includes("?")){let[t,e]=g.url.split(/\\?\?/);g.url=t,g.params=new URLSearchParams(e)}let c=g.url;if(c==="/favicon.ico")return C.writeHead(200,{"Content-Type":"text/plain"}),C.end("","utf-8");if(c==="/socketless.js")return C.writeHead(200,{"Content-Type":$(".js")}),C.end(D,"utf-8");if(!I.handle(c,g,C)){var o=eg(g.url,l);tg.readFile(o,(t,e)=>{if(t)return ig(o,C);C.writeHead(200,{"Content-Type":$(o)}),C.end(e,"utf-8")})}}}function Fg(l,I){l=j(l),I=E(I);let g=P(l),C={createServer:function(o){let t,e;o?.constructor===Object?e=o:t=o;let i=t;i||(i=e?Ig.createServer(e):gg.createServer());let n=new Cg({noServer:!0});i.on("upgrade",(Z,G,A)=>{n.handleUpgrade(Z,G,A,m=>{n.emit("connection",m,Z)})});let b=new I(n,i);return n.on("connection",function(Z){b.connectClientSocket(Z)}),i},createClient:function(o,t,e=l){o=o.replace("http","ws");let i=new Zg(o,{rejectUnauthorized:!t}),n=new e;i.on("close",(...Z)=>n.onDisconnect(...Z));function b(Z){try{let{name:G,payload:A}=JSON.parse(Z);G==="handshake:setid"&&(i.off("message",b),n.setState(A),n.connectServerSocket(i))}catch{}}return i.on("message",b),n},createWebClient:function(o,t,e,i){let n=C.createClient(o,i,g),b=new J(n),Z=q(t,b),G=e?Ig.createServer(e,Z):gg.createServer(Z),A=new Cg({noServer:!0});return G.on("upgrade",(m,Y,a)=>{A.handleUpgrade(m,Y,a,W=>{A.emit("connection",W,m)})}),n.ws=A,n.webserver=G,A.on("connection",m=>{n.connectBrowserSocket(m),m.on("message",async Y=>{Y=Y.toString();let{name:a,payload:W}=JSON.parse(Y),X=H(a);if(a==="syncState"){let w=await n.syncState();return m.send(JSON.stringify({name:X,payload:w}))}if(a==="disconnect")return n.disconnect();let s=n.server,B=a.split(":");for(;B.length;)s=s[B.shift()];let u=await s(...W);m.send(JSON.stringify({name:X,payload:u}))}),m.on("close",()=>{n.disconnectBrowserSocket()})}),G.addRoute=b.addRouteHandler.bind(b),G}};return C}export{Fg as generateClientServer};
